# 13.1 타입스크립트의 객체 지향

객체 지향을 이해하고 있는 FE 개발자라면 한 번쯤 이런 의문을 가져봤을 것이다. **"프론트엔드에 어떻게 객체 지향을 적용하지?"**

언뜻 보기에 객체 지향은 FE 개발과는 거리가 먼 개념처럼 느껴질 수 있다. 하지만 사실 이미 객체 지향을 적용하고 있다.
물론 JS로도 객체 지향 프로그래밍을 할 수 있다. JS는 프로토타입 기반의 객체 지향 언어로 분류된다. 그러나 JS는 전통적인 객체 지향 프로그래밍 언어에서 기대할 수 있는 일부 기능들을 지원하지 않아 객체 지향을 온전히 구현하는 데 부족함이 있다. 이러한 제약을 TS가 `private`과 같은 접근 제어자나 추상 클래스, 추상 메서드 같은 기능을 지원하면서 해결해준다. TS는 객체 지향을 구현할 수 있도록 도와주는 JS의 슈퍼셋으로 볼 수 있다.

TS는 점진적 타이핑, 구조적 타이핑 그리고 덕 타이핑이 결합된 언어이다. 이 3가지 개념이 섞인 언어는 흔치 않은데 이것들을 한데 모아 객체 지향의 폭을 넓혀준다.

- 점진적 타이핑은 프로그램 전체가 아닌 개발자가 명시한 일부분만 정적 타입 검사를 거치게 하고 나머지 부분은 그대로 동적 타입 검사가 이루어지게 하여 점진적 개선을 할 수 있도록 해준다.
- 덕 타이핑은 객체의 변수와 메서드 집합이 객체의 타입을 결정하게 해준다.
- 구조적 타이핑을 구조적 타입 시스템이라고도 부른다. 명시적인 선언이나 이름에 의존하여 명확한 상속 관계를 지향하는 노미널 타이핑과 달리, 구조적 타이핑은 객체의 속성에 해당하는 특정 타입의 속성을 갖는지를 검사하여 타입 호환성을 결정한다.

대표적인 노미널 타이핑 언어로 자바, C# 등을 들 수 있다. 노미널 타이핑 언어는 인터페이스와 클래스가 일대일로 대응된다. 그러나 타입스크립트 같은 구조적 타이핑 언어는 하나의 클래스에 여러 인터페이스가 연결될 수 있으며, 하나의 인터페이스에 여러 클래스가 연결될 수 있다. 게다가 앞서 언급했듯이 TS는 JS의 슈퍼셋으로 기존 웹 환경과 잘 호환되며, 객체 지향을 JS 보다 쉽게 표현할 수 있게 해준다. 이로 인해 비즈니르 로직을 TS로 좀 더 수월하게 구현할 수 있게 되었다.

TS를 활용해 FE에서 객체 지향을 구현할 수 있다. 객체는 별다른게 아니다. 우리가 자주 쓰고 있는 컴포넌트도 객체의 한 형태이다. 컴포넌트는 스스로 책임을 져야하는 역할을 수행하면서 다른 컴포넌트 객체와 협력하는 독립적인 객체이다. 컴포넌트를 조합하는 것도 객체 지향을 활용하는 것이라고 볼 수 있다. 물론 JSX 문법은 선언적이라는 특성이 있지만 이미 우리는 컴포넌트를 개발하면서 사실 객체 지향을 구현하고 있는 것이다.

그렇다면 객체 지향의 관점에서 TS가 FE에 어떤 이점을 주는지 살펴보자.

1. TS는 prop을 인터페이스로 정의할 수 있다. 객체 지향 패러다임에서는 객체 간의 협력 관계에 초점을 둔다. 컴포넌트 간의 협력 관계를 표현하는 것이 prop이다. 또한 객체 자체가 아니라 프레임워크에 의해 객체의 의존성이 주입되는 DI(의존성 주입) 패턴을 따르는데, 이러한 패턴을 더욱 명확하게 표현할 수 있게 해주는 것이 TS이다.

우리는 이미 리액트나 뷰 같은 도구를 사용하며 DI를 활용하고 있다. DI는 객체 간의 의존 관계를 설정하는 데 사용된다. DI를 구현하기 위해서는 A 클래스가 B 클래스에 의존한다고 하더라도, A가 B의 구체 클래스가 아닌 B의 인터페이스에 의존하도록 설계해야 한다. DI 패턴을 따르면 객체 간의 결합도를 낮출 수 있는데 TS로 DI 패턴을 더욱 명확하게 표현할 수 있다.

2. TS 자체가 객체 지향적으로 다양한 측면을 표현하는 데 큰 장점을 가지고 있다. 앞서 언급한 대로 TS는 점진적 타이핑, 구조적 타이핑, 덕 타이핑을 결합한 언어로 객체 지향의 폭을 넓혀준다.

FE 개발에서 객체 지향은 중요한 개념이다. 이쯤에서 한 번 고민해봐야 할게 있다. 객체 지향을 따르기 위해서는 객체 간의 협력과 역할에 집중해야 한다. 과연 우리는 컴포넌트를 만들 때 컴포넌트의 역할과 컴포넌트 간의 협력에 초점을 맞추고 있었을까?

사실, 웹 개발을 하면서 제대로 된 객체 지향을 구현하기 어려운 이유가 있다. 웹 개발에서는 선언적인 언어 또는 문법을 사용할 때가 있기 때문이다. 우리는 JSX와 같은 선언적인 문법을 사용하여 마크업을 처리한다. 일반적으로 객체 지향을 구현하려면 객체 간의 협력 관계를 먼저 고려하고, 메시지를 정의하여 해당 메시지를 수신할 알맞은 객체를 결정하는 절차를 따르게 된다.

하지만 HTML 마크업을 선언적으로 작성할 때는 컴포넌트 간의 관게를 먼저 떠올리기 어렵다. 디자인 요구 사항이 제시되어야 그에 맞춰 마크업을 진행할 수 밖에 없다. 이처럼 컴포넌트 간의 협력 관계를 먼저 고려하고 메시지를 정하는 것은 현실적으로 힘든 일이다. 게다가 애플리케이션의 변동 사항에 유연하게 대응하기 위해, 다시 말해 변경이 용이하고 유지보수성이 높은 설계를 하기 위해 객체 지향을 구현하는 것인데 사전에 레이아웃의 변화를 예측할 수 없다. 단지 레이아웃의 변경 사항이 생기면 그조 묵묵히 받아들일 뿐이다.

이러한 레이아웃의 변동에 좀 더 나은 대응을 하기 위해 MVP, MVC, MVVM 등의 다양한 패턴이 등장했지만 이것들이 만병통치약은 아니다. 선언적인 문법을 사용하면서 객체 지향을 완벽하게 구현한다는 것은 너무 이상적인 이야기다. 이 2가지를 균형 있게 유지하는 방법은 아직 존재하지 않는다.

컴포넌트만 객체일까? 아니다. 만약 어떤 상품이 존재하고 이를 담을 수 있는 장바구니가 있다고 가정해보자. 이들이 유기적으로 상호작용 한다면 객체라고 볼 수 있다. 리액트에서 컴포넌트는 props를 받아 결과물을 렌더링한다. 이때 props로 전달되는 값은 객체로 해석할 수도 있다. 또한 리뷰 데이터를 props로 받아 결과물을 렌더링하는 컴포넌트가 있다면, 이 리뷰 데이터를 각각의 원시값이 아닌 하나의 객체로 전달하여 사용할 수도 있을 것이다. 좀 더 크게 보면 상태 관리 측면에서 유기적인 객체를 생성할 수도 있을 것이다. 특히 MobX는 객체 지향 패러다임을 기반으로 한 대표적인 상태 관리 라이브러리이다.

그렇다면 어떻게 프론트엔드에서 객체 지향을 효과적으로 활용할 수 있을까? 회사의 전략과 프로젝트의 방향성에 따라 다양한 접근 방식이 있을 것이다. 특히 레이아웃은 예상치 못한 변동 사항이 생길 가능성이 높기 때문에 미확정 영역으로 두고 공통으로 사용되는 컴포넌트와 비즈니스 영역에서 객체 지향 원칙을 적용하여 설계하면 좋은 구조를 개발할 수 있을 것 이다.
