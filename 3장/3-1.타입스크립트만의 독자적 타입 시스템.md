# 3.1 타입스크립트만의 독자적 타입 시스템

## 타입스크립트만의 독자적 타입 시스템

타입스크립트는 자바스크립트 자료형에서 제시되지 않은 독자적인 타입 시스템을 가지고 있지만, 엄밀히 말하면 타입스크립트의 타입 시스템이 내포한 개념은 모두 자바스크립트에서 기인한 것이다. (단지 자바스크립트로 표현할 수단과 필요성이 없었을 뿐이다.) 자바스크립트의 슈퍼셋으로 정적 타이핑을 할 수 있는 타입스크립트가 등장하면서 비로서 타입스크립트의 타입시스템이 구축되었다.

이 장에서 소개하는 모든 타입 시스템은 타입스크립트에만 존재하는 키워드지만, 그 개념은 자바스크립트에 기인한 타입 시스템이라는 점을 인지하고 각 타입을 살펴보자.

앞으로 다룰 타입의 계층 구조를 그림으로 나타내면 아래와 같다.

<p align="center">
  <img width=500 src="https://github.com/team-Palindrome/TypeScript-Study/assets/133668286/6b9a8fff-c534-4f19-a3c6-99abc8f228e3">
</p>

## any

any 타입은 아래와 같은 특징을 가진다.

1. 자바스크립트에 존재하는 모든 값을 오류없이 받을 수 있다.
2. 타입을 명시하지 않은 것과 동일한 효과를 나타낸다.
3. 아래와 같이 any로 지정한 타입은 어떠한 값을 할당하더라도 오류가 발생하지 않는다.

```tsx
let state: any;

state = { value: 0 }; // 객체 할당
state = 100; // 숫자 할당
state = "hello world"; //문자열 할당
state.inner = () => console.log("any type"); // 중첩구조로 들어가 함수 할당
```

any타입은 타입스크립트로 달성하고자 하는 정적 타이핑의 의미를 무색하게 만들 수 있다. 따라서 any타입을 변수에 할당하는 것은 지양해야할 패턴으로 알려져 있다.

하지만 타입스크립트에서 any를 어쩔 수 없이 사용해야할 때가 있는데, 대표적으로 3가지 사례를 들 수 있다.

1. **개발단계에서 임시로 값을 지정해야할 때**

   매우 복잡한 구성 요소로 이루어진 개발 과정에서 추후 값이 변경될 여지가 있거나 타입에 대한 확정이 아직 이루어지지 않을 경우 any를 사용할 수 있다.

   다만 타입안전성을 해칠 위험이 있으므로 세부 스펙이 나오는 시점에서 타입을 대체하는 경우가 많으며 이 과정이 누락될 경우 문제가 발생할 수 있으므로 주의해야 한다.

2. **어떤 값을 받아올지 또는 넘겨줄지 정할 수 없을 때**

   API 요청 및 응답처리, 콜백 함수 전달 등 어떤 값의 타입을 명확하게 정하기 힘든 경우 any타입을 사용할 수 있다.

3. **값을 예측할 수 없을 때 암묵적으로 사용**

   외부 라이브러리나 웹 API요청에 의해 다양한 값을 반환하는 API가 존재할 수 있다.

   브라우저의 Fetch API의 일부 메서드는 요청 이후의 응답을 특정 포맷으로 파싱하는데 이때 반환 타입이 any로 매핑되어 있는 것을 확인 할 수 있다.

이렇게 예외적으로 any타입을 사용해야하는 상황이 있음에도 되도록 any타입은 지양하는게 좋다.

## unknown

unknown타입은 any 타입과 유사하게 모든 타입의 값이 할당될 수 있다. 그러나 unknown은 any 타입을 제외한 다른 타입으로 선언된 변수에는 unknown 타입 값을 할당할 수 없다.

| any | unknown |
| --- | ------- |

| - 어떤 타입이든 any타입에 할당 가능

- any타입은 어떤 타입으로도 할당 가능 (단, never제외) | - 어떤 타입이든 unknown타입에 할당 가능
- unknown 타입은 any타입 외에 다른 타입으로 할당 불가능 |

```tsx
let anyData: any;

anyData = "string";
anyData = () => {
  console.log("function");
};
anyData = 100;

let anyData2: string = anyData; // 할당 가능
```

```tsx
let unknownData: unknown;

unknownData = 100;
unknownData = "string";
unknownData = () => {
  console.log("function");
};

let unknownData3: any = unknownData; // 할당 가능
let unknownData2: string = unknownData; // "'unknown' 형식은 'string' 형식에 할당할 수 없습니다." 에러 발생
```

unknown 타입은 타입스크립트 3.0이 릴리스 될 때 추가되었는데, 기존 타입 시스템에서 부족한 부분을 보완하기 위해 등장했다. unknown 타입은 이름처럼 무엇이 할당될지 아직 모르는 상태의 타입을 말한다.

any 타입과 유사하지만 타입 검사를 강제하고 타입이 식별된 후에 사용할 수 있기 때문에 any 타입보다 더 안전하다.

```tsx
// 할당시에는 에러가 발생하지 않음
const unknownFunction: unknown = () => console.log("this is unknown");

// 하지만 실행시에는 에러가 발생; Error: Object is of type 'unknwon'.ts(2571)
unknownFunction();
```

비단 함수뿐만 아니라 객체의 속성 접근, 클래스 생성자 호출을 통한 인스턴스 생성 등 객체 내부에 접근하는 모든 시도에서 에러가 발생한다. unknown 타입은 어떤 타입이 할당되었는지 알 수 없음을 나타내기 때문에 unknown 타입으로 선언된 변수는 값을 가져오거나 내부 속성에 접근할 수 없다.

unknown 타입으로 할당된 변수는 어떤 값이든 올 수 있음을 의미하는 동시에 개발자에게 엄격한 타입 검사를 강제하는 것이다. 따라서 데이터 구조를 파악하기 힘든 경우 any 타입보다 unknown 타입으로 대체해서 사용하는 방법이 권장된다.

## void

**함수에서의 void 사용**

- 자바스크립트 함수에서 명시적인 반환문을 작성하지 않으면 undefined가 반환된다.
- 하지만 타입스크립트에서 함수가 어떤 값을 반환하지 않을 경우에는 void를 지정하여 사용한다.

```tsx
function logFunc(data: string): void {
  console.log(data);
  // return 없음
}

// 화살표 함수
const logFuncArrow = (data: string): void => {
  console.log(data);
  // return 없음
};
```

일반적으로 함수 자체를 다른 함수의 인자로 전달하는 경우가 아니라면 void 타입은 잘 명시되지 않는 경향이 있다. 함수내부의 별도 반환문이 없을 경우 타입스크립트 컴파일러가 void로 타입을 추론해주기 때문이다.

**변수에서 void 사용**

void는 주로 함수의 반환 타입으로 사용하지만 함수에 국한된 타입은 아니다. 다만 함수가 아닌 값에 대해서는 대부분 무의미하다.

- void로 타입이 지정된 변수는 undefined 또는 null만 할당할 수 있다.
- 만약 tsconfig.json에서 strictNullchecks옵션이 설정 되어 있거나 컴파일시 해당 플래그 설정이 실행되는 경우에는 null값을 할당할 수 없다.
- 또한 명시적인 관점에서도 undefined나 null을 직접사용해서 지정하는 것이 더 바람직하다.

일반적으로 함수 자체를 다른 함수의 인자로 전달하는 경우가 아니라면 void 타입은 잘 명시하지 않는 경향이 있다. 함수 내부에 별도 반환문이 없다면 타입스크립트 컴파일러가 알아서 함수 타입을 void로 추론해주기 때문이다.

## never

never 타입도 void와 마찬가지로 타입의 값을 반환할 수 없은 타입을 말한다. 보통은 **에러를 던지는 경우**와 **무한히 함수가 실행되는 경우**에 사용된다

**에러를 던지는 경우**

자바스크립트에서는 런타임에 의도적으로 에러를 발생시키고 캐치할 수 있다. throw 키워드를 사용하면 에러를 발생시킬 수 있는데, 이는 값을 반환하는 것으로 간주하지 않는다.

따라서 특정 함수가 실행 중 마지막에 에러를 던지는 작업을 수행한다면 해당 함수의 반환 타입은 never이다.

```tsx
// 에러를 던지는 경우
function generateError(res: Response): never {
  throw new Error(res.getMessage());
}
```

**무한히 함수가 실행되는 경우**

드물지만 함수 내에서 무한 루프를 실행하는 경우가 있을 수 있다. 무한 루프는 결국 함수가 종료되지 않음을 의미하기 때문에 값을 반환하지 못한다.

```tsx
// 무한히 함수 실행
function checksStatus(): never {
  while (true) {
    //...
  }
}
```

never 타입은 모든 타입의 하위 타입이다. 즉 never 자신을 제외한 어떤 타입도 never에 할당될 수 없다는 것을 의미한다. 심지어 any타입이라 할지라도 never 타입에 할당될 수 없다.

따라서 타입스크립트에서는 조건부 타입을 결정할 때 특정 조건을 만족하지 않는 경우에 엄격한 타입 검사 목적으로 never 타입을 명시적으로 사용하기도 한다. 이에 대한 예시는 5.1 조건부 타입에서 자세히 다룬다.

> **void와 never의 차이**
>
> 추가로 void와 never의 차이를 말하자면 함수의 완료여부에 달려있다. 에러를 던지거나 무한히 함수가 실행되는 것은 함수 자체가 끝난 것이 아니다.
>
> 실행중이거나 중단된 시점에 사용하는 것이 never다. void와 마찬가지로 반환값은 없지만 함수의 실행이 완료되었는지를 중심으로 생각하면 never와 void의 차이를 구분하는데 조금 더 도움이 될 것이다.

</aside>

## Array타입

타입스크립트에서 배열을 다루는 이유는 아래와 같다. 이와 같은 이유로 배열의 타입 시스템을 이 절에서 조금 더 자세히 다룰 것이다.

- 엄밀히 말하면 자바스크립트에서 배열은 객체에 속하는 타입으로 분류하며 단독으로 배열이라는 자료형에 국한하지 않는다. 즉 자바스크립트에서는 배열을 단독으로 배열이라는 자료형에 국한하지 않는다.
- 타입스크립트에서 Array라는 타입을 사용하기 위해서는 타입스크립트의 특수한 문법을 사용해야한다.

자바스크립트의 배열은 동적 언어의 특징에 따라 어떤 값이든 배열의 원소로 허용한다. 하지만 이러한 개념은 타입스크립트의 정적 타이핑과 부합하지 않는다.

대개 정적타입의 언어에서는 배열을 선언할 때 크기까지 동시에 제한하기도 한다. 자바, C++ 같은 다른 정적 언어에서도 배열의 원소로 하나의 타입만 사용하도록 명시한다. 타입스크립트에서는 배열의 크기까지 제한하지는 않지만 정적 타입의 특성을 살려 명시적인 타입을 선언함으로서 해당 타입의 원소를 관리하는 것을 강제한다.

자바스크립트에서 배열 타입을 Object.prototype.toString.call(…) 연산자로 확인해보면 Array가 반환된다. 타입스크립트는 이 키워드로 배열 타입을 선언하는 방법도 있는데, 이를 위해 제네릭이라는 특수한 문법을 사용한다. (뒤에서 자세히 설명 예정)

배열 타입을 선언하는 방식으로는 크게 두가지가 있다.

1. 자료형 + [ ]

   ```tsx
   const array: number[] = [1, 2, 3];
   ```

2. Array + 제네릭

   ```tsx
   const array: Array<number> = [1, 2, 3];
   ```

만약 여러 타입을 모두 관리해야 하는 배열을 선언하고 싶은 경우에는 유니온 타입을 사용할 수 있다.

```tsx
const array1: Array<number | string> = [1, "string"];
const array2: number[] | string[] = [1, "string"];
const array3: (number | string)[] = [1, "string"];
```

### **튜플**

튜플은 타입스크립트의 타입시스템과 대괄호를 사용해서 선언할 수 있다. 대괄호 안에 타입 시스템을 기술하는 것이 배열 타입과 유일하게 다른 점이다.

이때 대괄호 안에 선언하는 타입의 개수가 튜플이 가질 수 있는 원소의 개수를 나타낸다. 즉, 튜플은 배열의 특정 인덱스에 정해진 타입을 선언하는 것과 같다.

```tsx
let tuple: [number] = [1]; // O, 가능

tuple = [1, 2]; // X, 불가능
tuple = [1, "string"]; // X, 불가능

let tuple2: [number, string, boolean] = [1, "hello world", true]; // O, 가능
```

- 배열은 사전에 허용하지 않은 타입이 서로 섞이는 것을 방지하여 타입 안전성을 제공한다.
- 튜플은 여기에 길이까지 제한하여 원소의 개수와 타입을 보장한다.

이처럼 타입을 제한하는 것은 자바스크립트의 런타임 에러와 유지 보수의 어려움을 막기 위한 것이며 특히 튜플의 경우 컨벤션을 잘 지키고 각 배열 원소의 명확한 의미와 쓰임을 보장할 때 더욱 안전하게 사용할 수 있다.

튜플의 유용한 쓰임새를 알아보기 위해 사용자 인터페이스를 만들기 위한 자바스크립트 라이브러리인 리액트 예시를 살펴볼 수 있다. 훅 중 하나인 useState는 튜플 타입을 반환한다.

첫번째 원소는 훅으로부터 생성 및 관리되는 상태 값을 의미하고, 두 번째 원소는 해당 상태를 조작할 수 있는 세터(setter)를 의미한다.

_useState API에 대한 자세한 내용은 추후 추가_

또한 튜플은 옵셔널 프로퍼티(선택적 속성)을 명시하고 싶다면 물음표(?) 기호와 함께 해당 속성을 선언할 수 있다.

해당 원소는 옵셔널하기 때문에 해당 인덱스에 필수적으로 자리잡고 있지 않을 수 있음을 의미한다.

```tsx
const optionalTuple1 = [number, number, number?] = [1, 2];
const optionalTuple2 = [number, number, number?] = [1, 2, 3];
```

## **enum**

---

enum은 열거형이라고 부르는데, 타입스크립트에서 지원하는 특수한 타입이다.

enum은 일종의 구조체를 만드는 타입 시스템으로, enum을 사용하여 열거형을 정의할 수 있으며 각각의 멤버를 가진다. 자바스크립트와 객체와 유사한 모양이지만, **타입스크립트는 명명한 각 멤버의 값을 스스로 추론한다.**

기본적인 추론방식은 숫자 0부터 1씩 늘려가며 값을 할당하는 것이다.

```tsx
enum ProgrammingLanguage {
  Typescript, // 0
  Javascript, // 1
  Java, // 2
  Python, // 3
  Rust, // 4
}

// 각 멤버에게 접근하는 방식은 자바스크립트에서 객체의 속성에 접근하는 방식과 동일하다.
ProgrammingLanguage.Typescript; // 0
ProgrammingLanguage.Javascript; // 1
ProgrammingLanguage.Python; // 3
ProgrammingLanguage["Rust"]; // 4

// 역방향 접근도 가능하다.
ProgrammingLanguage[2]; // Java
```

명시적인 값의 할당도 가능하며 일부 멤버에 값을 할당하지 않아도 누락된 멤버를 아래와 같은 방식으로 이전 멤버를 기준으로 1씩 늘려가며 자동으로 할당한다.

```tsx
enum ProgrammingLanguage {
  Typescript = "TypeScript",
  Javascript = "JavaScript",
  Java = 300,
  Python = 400,
  Rust, // 401
  Go, // 402
}
```

enum타입은 주로 문자열 상수를 생성하는데 사용되며 이를 통해 응집력 있는 집합 구조체를 만들어 사용자 입장에서 간편하게 활용할 수 있다. 위 예시에서는 ProgrammingLanguage라는 이름의 열거형을 만들었는데, 이름에서 알 수 있듯이 각 멤버는 프로그래밍 언어와 관련된 값을 다룬다는 것을 쉽게 알 수 있다.

또한 그 자체로 변수 타입으로 지정할 수 있으며 열거형을 타입으로 가지는 변수는 해당 열거형이 가지는 모든 멤버들을 값으로 받을 수 있다. 다음과 같이 itemStatus라는 인자가 ItemStatusType라는 열거형을 타입으로 가지면 문자열로 타입이 지정되었을때와 비교하여 다음과 같은 효과가 있다.

```tsx
enum ItemStatusType {
  DELIVERY_HOLD = "DELIVERY_HOLD",
  DELIVERY_READY = "DELIVERY_READY",
  DELIVERING = "DELIVERING",
  DELIVERED = "DELIVERED",
}

const checkItemAvailable = (itemStatus: ItemStatusType) => {
  switch (itemStatus) {
    case ItemStatusType.DELIVERY_HOLD:
    case ItemStatusType.DELIVERY_READY:
    case ItemStatusType.DELIVERING:
      return false;
    case ItemStatusType.DELIVERED:
    default:
      return true;
  }
};
```

1. **타입안전성**: ItemStatusType에 명시되지 않은 다른 문자열은 인자로 받을 수 없어 타입 안전성이 우수하다.
2. **명확한 의미 전달과 높은 응집력**: ItemStatusType이 다루는 값이 무엇인지 명확하고 아이템 상태에 대한 값을 모아놓은 것으로 응집력이 우수하다.
3. **가독성**: 응집도가 높기 때문에 말하고자 하는 바가 더욱 명확하다. 열거형 멤버를 통해 어떤 상태를 나타내는지 쉽게 알 수 있다.

이처럼 열거형은 관련이 높은 멤버를 모아 문자열 상수처럼 사용하고자 할 때 유용하게 사용할 수 있다. 다만 얼거형을 사용할 때는 주의해야할 점이 있다.

1. 의도하지 않은 값의 할당이나 접근
   - 숫자로만 이루어져 있거나 타입스크립트가 자동으로 추론한 열거형은 안전하지 않은 결과를 낳을 수 있다.
     ex) 할당된 값을 넘어서는 범위에 역방향으로 접근 가능
   - 이러한 접근을 막기 위해 `cosnt enum`으로 열거형을 선언하는 방법이 있다. 이 방식은 역방향으로의 접근을 허용하지 않는다.
   - 다만, `const enum`으로 열거형을 선언하더라도 숫자 상수로 관리되는 열거형은 선언한 값 이외의 값을 할당하거나 접근할 때 막지 못한다. 반면 문자열 상수로 관리되는 열거형은 의도하지 않은 값의 할당이나 접근을 방지하므로 문자열 상수로 관리하는 것이 도움이 된다.
2. 불필요한 코드의 크기 증가
   - **열거형은 타입공간과 값 공간에 모두 사용**된다. 열거형은 TS에서 JS로 변환되며 즉시실행함수 형식으로 변환된다.
   - 이때 즉시 실행 함수로 변환된 값을 사용하지 않는 코드로 인식하지 못하는 경우가 발생하여 불필요한 코드의 크기가 증가하는 결과를 초래할 수 있다. (트리쉐이킹이 되지 않는다)
   - 이러한 문제를 해결하기 위해 앞서 언급한 const enum 또는 as const assertion을 사용하여 유니온 타입으로 열거형과 동일한 효과를 얻는 방법이 있다.
