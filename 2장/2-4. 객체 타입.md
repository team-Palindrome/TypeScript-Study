# 2.4 객체 타입

## 객체타입

---

앞서 언급한 7가지 원시타입에 해당하지 않는 값은 모두 객체 타입으로 분류할 수 있다. 자바스크립트에서 객체의 범주는 원시타입에 비해 굉장히 넓다. 

자바스크립트에서는 이런 값을 모두 객체라고 일컫는데 타입스크립트에서는 다양한 형태를 가지는 객체마다 개별적으로 타입을 지정할 수 있다.  

예를 들어 배열 또는 클래스를 타입으로 지정할 수 있으며 매우 복잡한 구조를 가진 객체도 타입으로 만들어 관리할 수 있다.

## object

---

**object** 타입은 `any` 타입과 유사하게 **객체에 대항하는 모든 타입 값을 유동적으로 할당할 수 있어 정적 타이핑의 의미가 크게 퇴색되기 때문에 가급적 사용하지 말도록 권장**되는 타입이다.

다만 `any`와는 다르게 원시 타입에 해당하는 값은 `object` 타입에 속하지 않는다.

```tsx
function isObject(value: object) {
  return (
    Object.prototype.toString.call(value).replace(/\[|\]|\s|object/g, "") ===
    "Object"
  );
}

// 객체, 배열, 정규 표현식, 함수, 클래스 등 모두 object 타입과 호환된다
isObject({});
isObject({ name: "KG" });
isObject([0, 1, 2]);
isObject(new RegExp("object"));
isObject(() => {
  console.log("hello wolrd");
});
isObject(class Class {});

// 그러나 원시 타입은 호환되지 않는다
isObject(20); // false
isObject("KG"); // false
```

## {}

---

중괄호({})는 자바스크립트에서 객체 리터럴 방식으로 객체를 생성할 때 사용한다. 타입스크립트에서 객체를 타이핑할 때도 중괄호를 쓸 수 있는데, 객체의 각 속성에 대한 타입을 중괄호 `{}` 안에 지정해주는 식으로 사용한다.

이것은 타이핑되는 객체가 중괄호 안에서 선언된 구조와 일치해야한다는 것을 말한다.

```tsx
// 정상
const noticePopup: { title: string; description: string } = {
  title: "IE 지원 종료 안내",
  description: "2022.07.15일부로 배민상회 IE 브라우저 지원을 종료합니다.",
};

// SyntaxError
const noticePopup: { title: string; description: string } = {
  title: "IE 지원 종료 안내",
  description: "2022.07.15일부로 배민상회 IE 브라우저 지원을 종료합니다.",
  startAt: "2022.07.15 10:00:00", // startAt은 지정한 타입에 존재하지 않으므로 오류
};
```

빈 객체를 생성할 때도 `{}`를 사용할 수 있지만, `{}` 타입으로 지정된 객체에는 어떤 값도 속성으로 할당할 수 없다. 사실 빈 객체 타입을 지정하기 위해서는 `{}` 보다는 유틸리티 타입으로 `Record<string, never>` 처럼 사용하는 것이 바람직하다. 이는 5장에서 살펴보도록 한다.

```tsx
let noticePopup: {} = {};

noticePopup.title = "IE 지원 종료 안내"; // (X) title 속성을 지정할 수 없음
```

`{}` 타입으로 지정된 객체는 완전히 비어있는 순수한 객체를 의미하는 것이 아니다. 자바스크립트의 프로토타입 체이닝 때문에 아래와 같이 기본 Object 객체의 메서드는 사용할 수 있다. 

타입스크립트에서 객체 래퍼를 타입으로 지정할 수 있지만 이러한 이유 때문에 소문자로 된 타입스크립트 타입체계를 사용하는게 일반적이다.

## array

---

타입스크립트는 자바스크립트 객체를 세분화해서 타입을 지정할 수 있는 타입 시스템을 갖고 있다고 했다. 자바스크립트에서는 흔히 사용하는 객체 자료구조 외에도 배열, 함수, 정규식 등이 객체 범주에 속한다.

타입스크립트에서는 이런 각각의 객체에 타입을 지정할 수 있다.

자바스크립트의 배열 자료구조는 원소를 자유롭게 추가하고 제거할 수 있으며, 타입 제한 없이 다양한 값을 다룬다. 즉 하나의 배열 안에 숫자, 문자열과 같은 서로 다른 값이 혼재될 수 있다. 

그러나 이런 쓰임은 타입스크립트가 추구하는 정적 타이핑 방향과 맞지 않는다.

타입스크립트에서는 배열을 `array`라는 별도 타입으로 다루며, **하나의 타입 값만 가질 수 있다**는 점에서 자바스크립트 배열보다 조금 더 엄격하다. 하지만 자바스크립트와 마찬가지로 원소 개수는 타입에 영향을 주지 않는다.

타입스크립트에서 배열 타입을 선언하는 방식은 `Array` 키워드로 선언하거나 `[]`를 사용해서 선언하는 방법이 있다. (두 방식은 결과적으로 같으므로 개인 취향 혹은 팀의 컨벤션에 따라 하나를 선택해서 사용하면 된다.)

```tsx
const getCartList = async (cartId: number[]) => {
  const res = await CartApi.GET_CART_LIST(cartId);
  return res.getData();
};

getCartList([]); // (O) 빈 배열도 가능하다
getCartList([1001]); // (O)
getCartList([1001, 1002, 1003]); // (O) number 타입 원소 몇 개가 들어와도 상관없다
getCartList([1001, "1002"]); // (X) ‘1002’는 string 타입이므로 불가하다
```

여기서 주의해야할 점은 **튜플 타입도 대괄호로 선언한다는 것**이다. (튜플은 이후에 좀 더 자세히 다룬다)

타입스크립트 튜플 타입은 배열과 유사하지만 **튜플의 대괄호 내부에는 선언 시점에 지정해준 타입 값만 할당**할 수 있으며 **원소 개수도 타입 선언 시점에 미리 정해진다**.

이것은 객체 리터럴에서 선언하지 않은 속성을 할당하거나, 선언한 속성을 할당하지 않았을 때 에러가 발생한다는 점과 비슷하다.

```tsx
const targetCodes: ["CATEGORY", "EXHIBITION"] = ["CATEGORY", "EXHIBITION"]; // (O)
const targetCodes: ["CATEGORY", "EXHIBITION"] = [
  "CATEGORY",
  "EXHIBITION",
  "SALE",
]; // (X) SALE은 지정할 수 없음
```

## type과 interface 키워드

---

앞에서 언급한 타입스크립트 object 타입은 실무에서는 잘 사용하지 않는다. 자바스크립트와 대응되는 예시를 보여주기 위해 언급했을 뿐이다. 객체를 타이핑하기 위해서는 타입스크립트에서만 독자적으로 사용할 수 있는 키워드를 사용하는게 일반적이다.

흔히 객체를 타이핑하기 위해 자주 사용하는 키워드로 **type**과 **interface**가 있다. 

중괄호를 사용한 객체 리터럴 방식으로 타입을 매번 일일이 지정하기에는 중복적인 요소가 많다. type과 interface 키워드를 사용해 다음과 같이 선언하면 반복적으로 사용돼도 중복 없이 해당 타입을 쓸 수 있다.

```tsx
type NoticePopupType = {
  title: string;
  description: string;
};

interface INoticePopup {
  title: string;
  description: string;
}

const noticePopup1: NoticePopupType = { ... };
const noticePopup2: INoticePopup = { ... };
};
```

## function

---

자바스크립트에서는 함수도 일종의 객체로 간주하지만 `typeof` 연산자로 함수 타입을 출력하면 `function`이라는 별도의 타입으로 분류한다는 것을 알 수 있다.

```tsx
function add(a, b) {
  return a + b;
}

console.log(typeof add); // ‘function’
```

마찬가지로 타입스크립트에서도 함수를 별도의 함수 타입으로 지정할 수 있다. 다만 앞서 살펴본 객체의 타이핑과 달리 주의해야할 점이 있다. 

1. 자바스크립트에서 `typeof` 연산자로 확인한 `**function` 이라는 키워드 자체를 타입으로 사용하지 않는다.**
2. 함수는 매개변수 목록을 받을 수 있는데 **타입스크립트에서는 매개변수도 별도의 타입으로 지정해야 한다.**

```tsx
function add(a: number, b: number): number {
  return a + b;
}
```

예시에서 매개변수 a와 b는 number 타입이 지정되고, 함수 이름 옆에 콜론과 함께 다시 number 타입으로 반환 값을 지정하고 있는 것을 볼 수 있다. 

위 예시는 타입스크립트에서 함수 작성시 매개변수와 반환 값에 대한 타입을 지정하는 문법을 설명한 것이다. 그런데 **함수 자체의 타입은 어떻게 지정**할 수 있을까? 

**→ 호출 시그니처(call signature)**를 정의하는 방식을 사용하면 된다. 

타입스크립트에서 함수의 타입을 명시할 때는 화살표 함수 방식으로 호출 시그니처를 정의한다. 이 방식은 자바스크립트의 화살표 함수와 유사하며 함수의 입력 파라미터와 반환 값의 타입을 명시할 수 있다.

```tsx
type add = (a: number, b: number) => number;
```

<aside>
📚 **호출 시그니처(Call Signature)** 

타입스크립트에서 함수 타입을 정의할 때 사용하는 문법이다. 함수 타입은 해당 함수가 받는 매개변수와 반환하는 값의 타입으로 결정된다. 호출 시그니처는 이러한 함수의 매개변수와 반환 값의 타입을 명시하는 역할을 한다.

</aside>

## QnA

---

<aside>
🤔 타입스크립트에서는 일반적으로 변수 타입을 명시적으로 선언하지 않아도 컴파일러가 자동으로 타입을 추론한다. 이 말은 타입스크립트 컴파일러가 변수 사용 방식과 할당된 값의 타입을 분석해서 타입을 유추한다는 것을 의미한다.

따라서 모든 변수에 타입을 일일이 명시적으로 선언할 필요가 없다.

그러나 타입 추론에 대해서는 다양한 의견이 있다. 컴파일러에 타입 추론을 온전히 맡길 것인지 명시적으로 타입을 선언할 것인지는 개인의 취향 또는 팀의 컨벤션에 따라 다를 수 있다.

</aside>